/*!
  * Bootstrap v5.3.0 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
let e; let t; e = this, t = function () {
  const e = new Map(); const t = { set(t, n, i) { e.has(t) || e.set(t, new Map()); const s = e.get(t); s.has(n) || s.size === 0 ? s.set(n, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`); }, get: (t, n) => e.has(t) && e.get(t).get(n) || null, remove(t, n) { if (!e.has(t)) return; const i = e.get(t); i.delete(n), i.size === 0 && e.delete(t); } }; const n = 'transitionend'; const i = (e) => (e && window.CSS && window.CSS.escape && (e = e.replace(/#([^\s"#']+)/g, ((e, t) => `#${CSS.escape(t)}`))), e); const s = (e) => { e.dispatchEvent(new Event(n)); }; const r = (e) => !(!e || typeof e !== 'object') && (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType); const o = (e) => (r(e) ? e.jquery ? e[0] : e : typeof e === 'string' && e.length > 0 ? document.querySelector(i(e)) : null); const l = (e) => { if (!r(e) || e.getClientRects().length === 0) return !1; const t = getComputedStyle(e).getPropertyValue('visibility') === 'visible'; const n = e.closest('details:not([open])'); if (!n) return t; if (n !== e) { const t = e.closest('summary'); if (t && t.parentNode !== n) return !1; if (t === null) return !1; } return t; }; const a = (e) => !e || e.nodeType !== Node.ELEMENT_NODE || !!e.classList.contains('disabled') || (void 0 !== e.disabled ? e.disabled : e.hasAttribute('disabled') && e.getAttribute('disabled') !== 'false'); const c = () => (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery') ? window.jQuery : null); const u = []; const d = () => document.documentElement.dir === 'rtl'; const h = (e, t = [], n = e) => (typeof e === 'function' ? e(...t) : n); const f = (e, t, i = !0) => { if (!i) return void h(e); const r = ((e) => { if (!e) return 0; let{ transitionDuration: t, transitionDelay: n } = window.getComputedStyle(e); const i = Number.parseFloat(t); const s = Number.parseFloat(n); return i || s ? (t = t.split(',')[0], n = n.split(',')[0], 1e3 * (Number.parseFloat(t) + Number.parseFloat(n))) : 0; })(t) + 5; let o = !1; const l = ({ target: i }) => { i === t && (o = !0, t.removeEventListener(n, l), h(e)); }; t.addEventListener(n, l), setTimeout((() => { o || s(t); }), r); }; const g = /[^.]*(?=\..*)\.|.*/; const p = /\..*/; const m = /::\d+$/; const
    _ = {}; let b = 1; const v = { mouseenter: 'mouseover', mouseleave: 'mouseout' }; const y = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']); function E(e, t) { return t && `${t}::${b++}` || e.uidEvent || b++; } function A(e) { const t = E(e); return e.uidEvent = t, _[t] = _[t] || {}, _[t]; } function C(e, t, n = null) { return Object.values(e).find(((e) => e.callable === t && e.delegationSelector === n)); } function w(e, t, n) { const i = typeof t === 'string'; const s = i ? n : t || n; let r = I(e); return y.has(r) || (r = e), [i, s, r]; } function T(e, t, n, i, s) { if (typeof t !== 'string' || !e) return; let[r, o, l] = w(t, n, i); if (t in v) { const e = (e) => function (t) { if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return e.call(this, t); }; o = e(o); } const a = A(e); const c = a[l] || (a[l] = {}); const u = C(c, o, r ? n : null); if (u) return void (u.oneOff = u.oneOff && s); const d = E(o, t.replace(g, '')); const h = r ? (function (e, t, n) { return function i(s) { const r = e.querySelectorAll(t); for (let{ target: o } = s; o && o !== this; o = o.parentNode) for (const l of r) if (l === o) return k(s, { delegateTarget: o }), i.oneOff && $.off(e, s.type, t, n), n.apply(o, [s]); }; }(e, n, o)) : (function (e, t) { return function n(i) { return k(i, { delegateTarget: e }), n.oneOff && $.off(e, i.type, t), t.apply(e, [i]); }; }(e, o)); h.delegationSelector = r ? n : null, h.callable = o, h.oneOff = s, h.uidEvent = d, c[d] = h, e.addEventListener(l, h, r); } function S(e, t, n, i, s) { const r = C(t[n], i, s); r && (e.removeEventListener(n, r, Boolean(s)), delete t[n][r.uidEvent]); } function O(e, t, n, i) { const s = t[n] || {}; for (const [r, o] of Object.entries(s))r.includes(i) && S(e, t, n, o.callable, o.delegationSelector); } function I(e) { return e = e.replace(p, ''), v[e] || e; } const $ = {
    on(e, t, n, i) { T(e, t, n, i, !1); }, one(e, t, n, i) { T(e, t, n, i, !0); }, off(e, t, n, i) { if (typeof t !== 'string' || !e) return; const [s, r, o] = w(t, n, i); const l = o !== t; const a = A(e); const c = a[o] || {}; const u = t.startsWith('.'); if (void 0 === r) { if (u) for (const n of Object.keys(a))O(e, a, n, t.slice(1)); for (const [n, i] of Object.entries(c)) { const s = n.replace(m, ''); l && !t.includes(s) || S(e, a, o, i.callable, i.delegationSelector); } } else { if (!Object.keys(c).length) return; S(e, a, o, r, s ? n : null); } }, trigger(e, t, n) { if (typeof t !== 'string' || !e) return null; const i = c(); let s = null; let r = !0; let o = !0; let l = !1; t !== I(t) && i && (s = i.Event(t, n), i(e).trigger(s), r = !s.isPropagationStopped(), o = !s.isImmediatePropagationStopped(), l = s.isDefaultPrevented()); const a = k(new Event(t, { bubbles: r, cancelable: !0 }), n); return l && a.preventDefault(), o && e.dispatchEvent(a), a.defaultPrevented && s && s.preventDefault(), a; },
  }; function k(e, t = {}) { for (const [n, i] of Object.entries(t)) try { e[n] = i; } catch (t) { Object.defineProperty(e, n, { configurable: !0, get: () => i }); } return e; } function D(e) { if (e === 'true') return !0; if (e === 'false') return !1; if (e === Number(e).toString()) return Number(e); if (e === '' || e === 'null') return null; if (typeof e !== 'string') return e; try { return JSON.parse(decodeURIComponent(e)); } catch (t) { return e; } } function x(e) { return e.replace(/[A-Z]/g, ((e) => `-${e.toLowerCase()}`)); } const N = {
    setDataAttribute(e, t, n) { e.setAttribute(`data-bs-${x(t)}`, n); }, removeDataAttribute(e, t) { e.removeAttribute(`data-bs-${x(t)}`); }, getDataAttributes(e) { if (!e) return {}; const t = {}; const n = Object.keys(e.dataset).filter(((e) => e.startsWith('bs') && !e.startsWith('bsConfig'))); for (const i of n) { let n = i.replace(/^bs/, ''); n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = D(e.dataset[i]); } return t; }, getDataAttribute: (e, t) => D(e.getAttribute(`data-bs-${x(t)}`)),
  }; class j {
    static get Default() { return {}; }

    static get DefaultType() { return {}; }

    static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!'); }

    _getConfig(e) { return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e; }

    _configAfterMerge(e) { return e; }

    _mergeConfigObj(e, t) {
      const n = r(t) ? N.getDataAttribute(t, 'config') : {}; return {
        ...this.constructor.Default, ...typeof n === 'object' ? n : {}, ...r(t) ? N.getDataAttributes(t) : {}, ...typeof e === 'object' ? e : {},
      };
    }

    _typeCheckConfig(e, t = this.constructor.DefaultType) { for (const [i, s] of Object.entries(t)) { const t = e[i]; const o = r(t) ? 'element' : (n = t) == null ? `${n}` : Object.prototype.toString.call(n).match(/\s([a-z]+)/i)[1].toLowerCase(); if (!new RegExp(s).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${i}" provided type "${o}" but expected type "${s}".`); } let n; }
  } class L extends j {
    constructor(e, n) { super(), (e = o(e)) && (this._element = e, this._config = this._getConfig(n), t.set(this._element, this.constructor.DATA_KEY, this)); }

    dispose() { t.remove(this._element, this.constructor.DATA_KEY), $.off(this._element, this.constructor.EVENT_KEY); for (const e of Object.getOwnPropertyNames(this)) this[e] = null; }

    _queueCallback(e, t, n = !0) { f(e, t, n); }

    _getConfig(e) { return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e; }

    static getInstance(e) { return t.get(o(e), this.DATA_KEY); }

    static getOrCreateInstance(e, t = {}) { return this.getInstance(e) || new this(e, typeof t === 'object' ? t : null); }

    static get VERSION() { return '5.3.0'; }

    static get DATA_KEY() { return `bs.${this.NAME}`; }

    static get EVENT_KEY() { return `.${this.DATA_KEY}`; }

    static eventName(e) { return `${e}${this.EVENT_KEY}`; }
  } const M = (e) => { let t = e.getAttribute('data-bs-target'); if (!t || t === '#') { let n = e.getAttribute('href'); if (!n || !n.includes('#') && !n.startsWith('.')) return null; n.includes('#') && !n.startsWith('#') && (n = `#${n.split('#')[1]}`), t = n && n !== '#' ? n.trim() : null; } return i(t); }; const P = {
    find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)), findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e), children: (e, t) => [].concat(...e.children).filter(((e) => e.matches(t))), parents(e, t) { const n = []; let i = e.parentNode.closest(t); for (;i;)n.push(i), i = i.parentNode.closest(t); return n; }, prev(e, t) { let n = e.previousElementSibling; for (;n;) { if (n.matches(t)) return [n]; n = n.previousElementSibling; } return []; }, next(e, t) { let n = e.nextElementSibling; for (;n;) { if (n.matches(t)) return [n]; n = n.nextElementSibling; } return []; }, focusableChildren(e) { const t = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(((e) => `${e}:not([tabindex^="-"])`)).join(','); return this.find(t, e).filter(((e) => !a(e) && l(e))); }, getSelectorFromElement(e) { const t = M(e); return t && P.findOne(t) ? t : null; }, getElementFromSelector(e) { const t = M(e); return t ? P.findOne(t) : null; }, getMultipleElementsFromSelector(e) { const t = M(e); return t ? P.find(t) : []; },
  }; const X = '.bs.swipe'; const q = `touchstart${X}`; const Y = `touchmove${X}`; const F = `touchend${X}`; const K = `pointerdown${X}`; const W = `pointerup${X}`; const V = { endCallback: null, leftCallback: null, rightCallback: null }; const B = { endCallback: '(function|null)', leftCallback: '(function|null)', rightCallback: '(function|null)' }; class H extends j {
    constructor(e, t) { super(), this._element = e, e && H.isSupported() && (this._config = this._getConfig(t), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents()); }

    static get Default() { return V; }

    static get DefaultType() { return B; }

    static get NAME() { return 'swipe'; }

    dispose() { $.off(this._element, X); }

    _start(e) { this._supportPointerEvents ? this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX) : this._deltaX = e.touches[0].clientX; }

    _end(e) { this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), h(this._config.endCallback); }

    _move(e) { this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX; }

    _handleSwipe() { const e = Math.abs(this._deltaX); if (e <= 40) return; const t = e / this._deltaX; this._deltaX = 0, t && h(t > 0 ? this._config.rightCallback : this._config.leftCallback); }

    _initEvents() { this._supportPointerEvents ? ($.on(this._element, K, ((e) => this._start(e))), $.on(this._element, W, ((e) => this._end(e))), this._element.classList.add('pointer-event')) : ($.on(this._element, q, ((e) => this._start(e))), $.on(this._element, Y, ((e) => this._move(e))), $.on(this._element, F, ((e) => this._end(e)))); }

    _eventIsPointerPenTouch(e) { return this._supportPointerEvents && (e.pointerType === 'pen' || e.pointerType === 'touch'); }

    static isSupported() { return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0; }
  } const Q = '.bs.carousel'; const R = '.data-api'; const z = 'next'; const U = 'prev'; const J = 'left'; const Z = 'right'; const G = `slide${Q}`; const ee = `slid${Q}`; const te = `keydown${Q}`; const ne = `mouseenter${Q}`; const ie = `mouseleave${Q}`; const se = `dragstart${Q}`; const re = `load${Q}${R}`; const oe = `click${Q}${R}`; const le = 'carousel'; const ae = 'active'; const ce = '.active'; const ue = '.carousel-item'; const de = ce + ue; const he = { ArrowLeft: Z, ArrowRight: J }; const fe = {
    interval: 5e3, keyboard: !0, pause: 'hover', ride: !1, touch: !0, wrap: !0,
  }; const ge = {
    interval: '(number|boolean)', keyboard: 'boolean', pause: '(string|boolean)', ride: '(boolean|string)', touch: 'boolean', wrap: 'boolean',
  }; class pe extends L {
    constructor(e, t) { super(e, t), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = P.findOne('.carousel-indicators', this._element), this._addEventListeners(), this._config.ride === le && this.cycle(); }

    static get Default() { return fe; }

    static get DefaultType() { return ge; }

    static get NAME() { return 'carousel'; }

    next() { this._slide(z); }

    nextWhenVisible() { !document.hidden && l(this._element) && this.next(); }

    prev() { this._slide(U); }

    pause() { this._isSliding && s(this._element), this._clearInterval(); }

    cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval); }

    _maybeEnableCycle() { this._config.ride && (this._isSliding ? $.one(this._element, ee, (() => this.cycle())) : this.cycle()); }

    to(e) { const t = this._getItems(); if (e > t.length - 1 || e < 0) return; if (this._isSliding) return void $.one(this._element, ee, (() => this.to(e))); const n = this._getItemIndex(this._getActive()); if (n === e) return; const i = e > n ? z : U; this._slide(i, t[e]); }

    dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose(); }

    _configAfterMerge(e) { return e.defaultInterval = e.interval, e; }

    _addEventListeners() { this._config.keyboard && $.on(this._element, te, ((e) => this._keydown(e))), this._config.pause === 'hover' && ($.on(this._element, ne, (() => this.pause())), $.on(this._element, ie, (() => this._maybeEnableCycle()))), this._config.touch && H.isSupported() && this._addTouchEventListeners(); }

    _addTouchEventListeners() { for (const e of P.find('.carousel-item img', this._element))$.on(e, se, ((e) => e.preventDefault())); const e = { leftCallback: () => this._slide(this._directionToOrder(J)), rightCallback: () => this._slide(this._directionToOrder(Z)), endCallback: () => { this._config.pause === 'hover' && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval)); } }; this._swipeHelper = new H(this._element, e); }

    _keydown(e) { if (/input|textarea/i.test(e.target.tagName)) return; const t = he[e.key]; t && (e.preventDefault(), this._slide(this._directionToOrder(t))); }

    _getItemIndex(e) { return this._getItems().indexOf(e); }

    _setActiveIndicatorElement(e) { if (!this._indicatorsElement) return; const t = P.findOne(ce, this._indicatorsElement); t.classList.remove(ae), t.removeAttribute('aria-current'); const n = P.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement); n && (n.classList.add(ae), n.setAttribute('aria-current', 'true')); }

    _updateInterval() { const e = this._activeElement || this._getActive(); if (!e) return; const t = Number.parseInt(e.getAttribute('data-bs-interval'), 10); this._config.interval = t || this._config.defaultInterval; }

    _slide(e, t = null) {
      if (this._isSliding) return; const n = this._getActive(); const i = e === z; const s = t || ((e, t, n, i) => { const s = e.length; let r = e.indexOf(t); return r === -1 ? !n && i ? e[s - 1] : e[0] : (r += n ? 1 : -1, i && (r = (r + s) % s), e[Math.max(0, Math.min(r, s - 1))]); })(this._getItems(), n, i, this._config.wrap); if (s === n) return; const r = this._getItemIndex(s); const o = (t) => $.trigger(this._element, t, {
        relatedTarget: s, direction: this._orderToDirection(e), from: this._getItemIndex(n), to: r,
      }); if (o(G).defaultPrevented) return; if (!n || !s) return; const l = Boolean(this._interval); this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(r), this._activeElement = s; const a = i ? 'carousel-item-start' : 'carousel-item-end'; const c = i ? 'carousel-item-next' : 'carousel-item-prev'; s.classList.add(c), ((e) => { e.offsetHeight; })(s), n.classList.add(a), s.classList.add(a), this._queueCallback((() => { s.classList.remove(a, c), s.classList.add(ae), n.classList.remove(ae, c, a), this._isSliding = !1, o(ee); }), n, this._isAnimated()), l && this.cycle();
    }

    _isAnimated() { return this._element.classList.contains('slide'); }

    _getActive() { return P.findOne(de, this._element); }

    _getItems() { return P.find(ue, this._element); }

    _clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null); }

    _directionToOrder(e) { return d() ? e === J ? U : z : e === J ? z : U; }

    _orderToDirection(e) { return d() ? e === U ? J : Z : e === U ? Z : J; }

    static jQueryInterface(e) { return this.each((function () { const t = pe.getOrCreateInstance(this, e); if (typeof e !== 'number') { if (typeof e === 'string') { if (void 0 === t[e] || e.startsWith('_') || e === 'constructor') throw new TypeError(`No method named "${e}"`); t[e](); } } else t.to(e); })); }
  } let me; let _e; return $.on(document, oe, '[data-bs-slide], [data-bs-slide-to]', (function (e) { const t = P.getElementFromSelector(this); if (!t || !t.classList.contains(le)) return; e.preventDefault(); const n = pe.getOrCreateInstance(t); const i = this.getAttribute('data-bs-slide-to'); return i ? (n.to(i), void n._maybeEnableCycle()) : N.getDataAttribute(this, 'slide') === 'next' ? (n.next(), void n._maybeEnableCycle()) : (n.prev(), void n._maybeEnableCycle()); })), $.on(window, re, (() => { const e = P.find('[data-bs-ride="carousel"]'); for (const t of e)pe.getOrCreateInstance(t); })), me = pe, _e = () => { const e = c(); if (e) { const t = me.NAME; const n = e.fn[t]; e.fn[t] = me.jQueryInterface, e.fn[t].Constructor = me, e.fn[t].noConflict = () => (e.fn[t] = n, me.jQueryInterface); } }, document.readyState === 'loading' ? (u.length || document.addEventListener('DOMContentLoaded', (() => { for (const e of u)e(); })), u.push(_e)) : _e(), { Carousel: pe };
}, typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : (e = typeof globalThis !== 'undefined' ? globalThis : e || self).bootstrap = t();
